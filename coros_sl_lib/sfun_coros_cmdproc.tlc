%% File : sfun_coros_cmdproc.tlc
%%
%% Description: 
%%   Simulink Coder TLC Code Generation file for sfun_coros_cmdproc
%%   This file server as core code generation for CoROS (Calibration on ROS protocol)
%%   1. Generate MODEL_cmdproc.c and MODEL_cmdproc.h file with protocol implementation code
%%   2. Collects all calibration parameters across the model and generate a table with address pointer, allow further direct modification of value 
%%   
%%

/%

 %/

%implements sfun_coros_cmdproc "C"


%function tmpFcnMapDataType(sldt)
%switch sldt
    %case "uint8"
        %return "CoROS_DTIDX_UINT8"
    %case "uint16"
        %return "CoROS_DTIDX_UINT16"
    %case "uint32"
        %return "CoROS_DTIDX_UINT32"
    %case "int16"
        %return "CoROS_DTIDX_INT16"
    %case "int32"
        %return "CoROS_DTIDX_INT32"
    %case "int64"
        %return "CoROS_DTIDX_INT64"
    %case "single"
        %return "CoROS_DTIDX_FLOAT"
    %case "double"
        %return "CoROS_DTIDX_DOUBLE"
    %default
        %return "CoROS_DTIDX_UINT8"
%endswitch
%endfunction


%% Function: BlockTypeSetup ===============================================
%%
%function BlockTypeSetup(block, system) void
  %%
  %%if ::GenCPP==1
    %%<LibReportFatalError("This S-Function generated by the Legacy Code Tool must be only used with the C Target Language")>
  %%endif

%% ---------GENREATE CALIBRATION PARAMETER TABLE TO BUFFER--------------
%openfile paratablebuffer
%openfile jsonfilebuffer_para

%assign paracount = 0
%with CompiledModel.ModelParameters
  %foreach modelParamIdx = NumParameters
    %assign thisModelParam = Parameter[modelParamIdx]
    %assign paramName = thisModelParam.Identifier
    %assign paramAddr = LibModelParameterAddr(thisModelParam, "", "", 0)
    %if EXISTS("thisModelParam.Object.ObjectProperties")
      %with thisModelParam.Object.ObjectProperties
        %assign thisvalue = Value
        %assign paradt = DataType
        %assign paradim = Dimensions
        %with CoderInfo.Object.ObjectProperties
          %if StorageClass=="ExportedGlobal"
            %assign paracount = paracount+1
            %assign dim1 = CAST("Number", %<paradim[0]>)
            %assign dim2 = CAST("Number", %<paradim[1]>)
            %selectfile paratablebuffer
           {%<paracount-1>,	%<tmpFcnMapDataType(paradt)>,	{%<dim1>, %<dim2>},	"%<paramName>",	%<paramAddr>},
            %selectfile jsonfilebuffer_para
            %assign valuestr_jsonformat = FEVAL("coros_rmvtrailingF", FEVAL("strrep", FEVAL("strrep", STRING(thisvalue), "{", "["), "}", "]"))
            {"Name":"%<paramName>",  "DataID":%<paracount-1>, "DataType":"%<paradt>" , "Dimension":[%<dim1>, %<dim2>],  "Value":%<valuestr_jsonformat>},
          %endif
        %endwith
        %% ***********************************
      %endwith
    %endif
  %endforeach
%endwith

%closefile paratablebuffer
%closefile jsonfilebuffer_para
%assign paratablebuffer_notrailcomma = FEVAL("strip", FEVAL("strip", paratablebuffer), ",")
%assign jsonfilebuffer_para_notrailcomma = FEVAL("strip", FEVAL("strip", jsonfilebuffer_para), ",")


%% 
%% ---------GENREATE SIGNAL OBJECT VALUE TABLE TO BUFFER--------------
%openfile sigtablebuffer
%openfile jsonfilebuffer_sig
%assign sigcount = 0
%with CompiledModel.BlockOutputs
  %foreach blockOutputIdx = NumExternalBlockOutputs
    %assign thisBlockOutput = ExternalBlockOutput[blockOutputIdx]
    %assign signalName = thisBlockOutput.Identifier
    %if EXISTS("thisBlockOutput.Object.ObjectProperties")
      %with thisBlockOutput.Object.ObjectProperties
        %assign sigdt = DataType
        %assign sigdim = CAST("Number",Dimensions)
        %with CoderInfo.Object.ObjectProperties
          %assign storageClassInObject  = StorageClass
          %if StorageClass=="ExportedGlobal"
            %assign sigcount = sigcount+1
          %endif
        %endwith
        %selectfile sigtablebuffer
        %% NOTE: The signal address simply use "&"+Name pattern, possible bug, yet to be refined
        {%<sigcount-1>,	%<tmpFcnMapDataType(sigdt)>,	%<sigdim>,	"%<signalName>",	&%<signalName>},
        %selectfile jsonfilebuffer_sig
        {"Name":"%<signalName>",  "DataID":%<sigcount-1>, "DataType":"%<sigdt>" , "Dimension":%<sigdim>},
      %endwith
    %endif
  %endforeach
%endwith

%closefile sigtablebuffer
%closefile jsonfilebuffer_sig
%assign sigtablebuffer_notrailcomma = FEVAL("strip", FEVAL("strip", sigtablebuffer), ",")
%assign jsonfilebuffer_sig_notrailcomma = FEVAL("strip", FEVAL("strip", jsonfilebuffer_sig), ",")






%% ---------GENREATE HEADER FILE--------------
%assign hFileName = "CoROS_CmdProc_" + CompiledModel.Name
%openfile coros_hfile = "%<hFileName>.h"
#ifndef COROS_CMDPROC_H
#define COROS_CMDPROC_H

///////////////////////////////////////////////////////////////
/* COROS COMMON DEFINITION */
//#include "%<LibGetMdlPubHdrBaseName()>.h"
#define COROS_SL_MAXBUFSIZE_DATA 128 //Simulink ROS variable size message setting: buffer size for data
#define COROS_SL_MAXBUFSIZE_STR 128 //Simulink ROS variable size message setting: buffer size for string
#define COROS_CMDOPTION_LEN 8   //Command option length of protocol

/* 	CoROS: Calibration on ROS */

#define COROS_CMDCODE_READCALDATA_NAME		0x10
#define COROS_CMDCODE_READCALDATA_IDX		0x11

#define COROS_CMDCODE_SETCALDATA_NAME		0x20 //Set calibration data by value
#define COROS_CMDCODE_SETCALDATA_DATAID 	0x21 //Set calibration data by DATAID

#define COROS_CMDCODE_SETDAQLIST			0x40
#define COROS_CMDCODE_GETCURRDAQLIST		0x41
#define COROS_CMDCODE_APPENDDAQLIST			0x42
#define COROS_CMDCODE_RMVDAQLIST			0x43


#define COROS_CMDCODE_STARTDAQ				0x50
#define COROS_CMDCODE_STOPDAQ				0x51

#define COROS_CMDCODE_DBG1             0x1000
#define COROS_CMDCODE_DBG2             0x2000

#define COROS_POS_RESPCODE(CMDCODE)				(0x8000 | CMDCODE)
#define COROS_NEG_RESPCODE(CMDCODE)				(0x4000 | CMDCODE)


typedef enum {
	COROS_OK                  = 0,
	COROS_NOK_INVALIDNAME     = 1, 
	COROS_NOK_IDXOUTOFBOUNDS  = 2,
  COROS_NOK_VERSION_NOTMATCH = 3,
  COROS_NOK_TXQUEUEULL      = 11
} CoROS_RtnCode;

typedef enum {
	CoROS_DTIDX_INT8 = 0,
	CoROS_DTIDX_UINT8 = 1,
	CoROS_DTIDX_UINT16 = 2,
    CoROS_DTIDX_UINT32 = 3,
    CoROS_DTIDX_INT16 = 4,
    CoROS_DTIDX_INT32 = 5,
    CoROS_DTIDX_INT64 = 6,
	CoROS_DTIDX_FLOAT = 7,
	CoROS_DTIDX_DOUBLE = 8,
  CoROS_DTIDX_UNKNOWN = 255
} CoROS_DTIDX;

extern const char* COMPILED_TIME_VERSION;

///////////////////////////////////////////////////////////////
/* COROS RX */

typedef struct {
  unsigned int Index;
  CoROS_DTIDX DataType;
  unsigned short Dimensions[2];              //Allow maximum 65535 each dim
  const char* Name;                 // Name length should less than COROS_SL_MAXBUFSIZE_STR
  void* pData;
} CoROS_CalParam;


typedef struct {
  unsigned int Index;
  CoROS_DTIDX DataType;
  int Dimensions;
  const char* Name;                 // Name length should less than COROS_SL_MAXBUFSIZE_STR
  void* pData;
} CoROS_Signal;


// Command Message Struct Definition is as follows:
typedef struct {
	unsigned int cmdcode; //Command Code
	char* cmdstr; //Command string, max COROS_SL_MAXBUFSIZE_STR characters
	unsigned int* cmdoption; //Command options, array with 8 elements
	unsigned char *pdata; // Data field, max COROS_SL_MAXBUFSIZE_DATA
	unsigned int datalen; // Valid data length of data field (maybe truncated from original), adapt with MATLAB ROS conversion
	unsigned int datalen_recvd; // Original data length of data field, adapt with MATLAB ROS conversion
} CoROS_CmdMsg;


///////////////////////////////////////////////////////////////
/* COROS TX */

/* 	Response Message Struct Definition is as follows: */
typedef struct {
	unsigned int respcode ; //Response Code
	unsigned int time[2] ; //ROS message <time>
	char respstr[COROS_SL_MAXBUFSIZE_STR]; //Response string, max COROS_SL_MAXBUFSIZE_STR characters
	unsigned int respoption[8]; //Response options
	unsigned char pdata[COROS_SL_MAXBUFSIZE_DATA]; // Data field, max COROS_SL_MAXBUFSIZE_DATA
	unsigned int datalen; // Valid data length of data field
} CoROS_RespMsg;

/* Item in ODT (Object Description Table, XCP like concept) */
typedef struct {
  unsigned char msgindex; // index of DAQ TX packet
  unsigned char msgoffset; // byte offset in DAQ TX packet
  unsigned short signalid; //Signal ID
  unsigned short varoffset; // byte offset of variable (e.g. elements in structure or array)
  unsigned char bytelength; // uint8 byte length of the signal starting from varoffset
  //CoROS_DTIDX datatype; // Data type
} CoROS_ODTItem;

typedef struct {
  unsigned int count; // number of ODT Items
  CoROS_ODTItem* odt_items; 
} CoROS_DAQList;


extern CoROS_CmdMsg coros_cmdmsg;
extern CoROS_CalParam CoROS_CalParamTable[%<paracount>];
void cmdDispatch(CoROS_CmdMsg *p_cmdmsg);
CoROS_RtnCode cmdCallback_setCalValueByName(CoROS_CmdMsg *p_cmdmsg);
CoROS_RtnCode cmdCallback_readCalValueByName(CoROS_CmdMsg *p_cmdmsg);



// CoROS_RtnCode cmdCallback_getCurrDAQList(CoROS_CmdMsg *p_cmdmsg);
// CoROS_RtnCode cmdCallback_appendToDAQList(CoROS_CmdMsg *p_cmdmsg);
// CoROS_RtnCode cmdCallback_removeFromDAQList(CoROS_CmdMsg *p_cmdmsg);


CoROS_RtnCode setCalValue_Scalar(void* pdst, unsigned char* psrc, CoROS_DTIDX datatype);
CoROS_RtnCode setCalValue_RectMatrix(void* pdst, unsigned char* psrc, CoROS_DTIDX datatype, unsigned int* dims, unsigned int* index);
CoROS_RtnCode getCalParamItemByName(char *calname, CoROS_CalParam** pp_calparamitem);


/*DEBUG FUNCTIONS*/
void cmdCallback_dbgprint(unsigned short idx); //print calibration as per idx
void printCmdMsg(CoROS_CmdMsg *p_cmdmsg);
void printRespMsg(CoROS_RespMsg* p_respmsg);

//////////////////////////////////////////////////
/*DAQ Functions*/
extern unsigned int coros_daq_enable;
extern CoROS_DAQList coros_daq_list;
extern CoROS_Signal CoROS_SignalTable[%<sigcount>];


void processDAQList();
CoROS_RtnCode cmdCallback_setDAQList(CoROS_CmdMsg *p_cmdmsg); 
CoROS_RtnCode cmdCallback_startDAQ(CoROS_CmdMsg *p_cmdmsg);
CoROS_RtnCode cmdCallback_stopDAQ(CoROS_CmdMsg *p_cmdmsg);

#endif
%closefile coros_hfile
%% ---------GENREATE H FILE END--------------




%% ---------GENREATE CPP FILE--------------
%assign cFileName = "CoROS_CalParams_" + CompiledModel.Name
%assign txqueue_hFileName = "CoROS_TxQueue_" + CompiledModel.Name
%openfile coros_cfile = "%<cFileName>.cpp"


#include <stdio.h>
#include <cstdlib>
#include <cstring>
#include "%<hFileName>.h"
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<txqueue_hFileName>.h"

%assign random_version_id = FEVAL("datestr",FEVAL("now"),30)
/*Use compiled time (ISO 8601 - yyyymmddTHHMMSS) as version*/

CoROS_CmdMsg coros_cmdmsg;
const char* COMPILED_TIME_VERSION = "%<random_version_id>";
CoROS_CalParam CoROS_CalParamTable[%<paracount>] = {
%<paratablebuffer_notrailcomma>
};

unsigned int coros_daq_enable = 0x0;
CoROS_DAQList coros_daq_list = {0, NULL};
CoROS_Signal CoROS_SignalTable[%<sigcount>] = {
%<sigtablebuffer_notrailcomma>
};

const unsigned char DTSIZE[9] = {1, 1, 2, 4, 2, 4, 8, 4, 8}; //Data size index of CoROS_DTIDX
const unsigned int COROS_NUM_CALPARAMS = %<paracount>;

void cmdDispatch(CoROS_CmdMsg *p_cmdmsg)
{
    printf("\n##COROS LOG# cmdDispatch# Command Received: %04X | CmdStr: %s\n", p_cmdmsg->cmdcode, p_cmdmsg->cmdstr);
    CoROS_RtnCode rtncode= (CoROS_RtnCode)0xFF;

	switch (p_cmdmsg->cmdcode)
	{
	case COROS_CMDCODE_SETCALDATA_NAME:
		rtncode = cmdCallback_setCalValueByName(p_cmdmsg);
		break;
	case COROS_CMDCODE_READCALDATA_NAME:
    rtncode = cmdCallback_readCalValueByName(p_cmdmsg);
		break;
  case COROS_CMDCODE_SETDAQLIST:
    rtncode = cmdCallback_setDAQList(p_cmdmsg);
    break;
  case COROS_CMDCODE_STARTDAQ:
    rtncode = cmdCallback_startDAQ(p_cmdmsg);
    break;
  case COROS_CMDCODE_STOPDAQ:
    rtncode = cmdCallback_stopDAQ(p_cmdmsg);
    break;
	case COROS_CMDCODE_DBG1: {
        unsigned short idx = (unsigned short)p_cmdmsg->cmdoption[0];
        cmdCallback_dbgprint(idx);
		break;}
	default:
        break;
	}
  //printf("\n##COROS DBG# cmdDispatch: Return Code %u\n", rtncode);
}

/////////////////////////////////////
CoROS_RtnCode cmdCallback_setCalValueByName(CoROS_CmdMsg *p_cmdmsg)
{
	CoROS_CalParam *p_calparamitem;
  char *calname = p_cmdmsg->cmdstr;
  unsigned int *index = p_cmdmsg->cmdoption;
  unsigned char *p_cmddata = p_cmdmsg->pdata;
  // Fill in response message
  CoROS_RespMsg* p_respmsg;
  getQueueSlot(&p_respmsg); // get an empty slot from TX queue
  strcpy(p_respmsg->respstr, calname); //same as in put
  memcpy(p_respmsg->respoption, index, sizeof(unsigned int)*8); //unsigned int [8] //same as input
  p_respmsg->datalen = 0;

	CoROS_RtnCode rtnval = getCalParamItemByName(calname, &p_calparamitem);
    //printf("##COROS DBG# cmdCallback_setCalValueByName: %s - Match Result: %u\n",calname ,rtnval);
    //printf("##COROS DBG# Matched Parameter: #%u %s [%u %u] Datatype: %u \n",p_calparamitem->Index, p_calparamitem->Name, p_calparamitem->Dimensions[0], p_calparamitem->Dimensions[1], p_calparamitem->DataType);
	if (!rtnval) // if calibration name found
	{
		unsigned short dim1 = p_calparamitem->Dimensions[0]; //rows along y-axis
		unsigned short dim2 = p_calparamitem->Dimensions[1]; //columns along x-axis
		if (dim1 > 1 || dim2 > 1)
		{
			/*Simulink 2D Table is stored columnwise in memory, index increases from top left to bottom right*/
			unsigned int xl = index[0]; // X-Left bound, zero indexed
			unsigned int xr = index[1]; // X-Right bound, zero indexed
			unsigned int yt = index[2]; // Y-Top bound, zero indexed
			unsigned int yb = index[3]; // X-Bottom bound, zero indexed
			unsigned int idx[4] = {xl, xr, yt, yb};
            printf("##COROS DBG# cmdCallback_setCalValueByName: Dim [%u %u] Index[%u %u %u %u]\n", dim1, dim2, xl,xr,yt,yb);
			if (yb >= dim1 || xr >= dim2)
			{
        p_respmsg->respcode = COROS_NEG_RESPCODE(p_cmdmsg->cmdcode);
				return COROS_NOK_IDXOUTOFBOUNDS;
			}
			else
			{
                unsigned int dims[2] = {(unsigned int)dim1, (unsigned int)dim2};
				rtnval = setCalValue_RectMatrix(p_calparamitem->pData, p_cmddata, p_calparamitem->DataType, dims, idx);
			}
		}
		else
		{
			setCalValue_Scalar(p_calparamitem->pData, p_cmddata, p_calparamitem->DataType);
		}
	}
  // fill in reponse code
  p_respmsg->respcode = rtnval? COROS_NEG_RESPCODE(p_cmdmsg->cmdcode):COROS_POS_RESPCODE(p_cmdmsg->cmdcode);
	return rtnval;
}

/**/
CoROS_RtnCode cmdCallback_readCalValueByName(CoROS_CmdMsg *p_cmdmsg){
  CoROS_CalParam *p_calparamitem;
  CoROS_RespMsg* p_respmsg;
	CoROS_RtnCode rtnval = getCalParamItemByName(p_cmdmsg->cmdstr, &p_calparamitem);
  if (!rtnval){
    unsigned short dim1 = p_calparamitem->Dimensions[0]; //rows along y-axis
		unsigned short dim2 = p_calparamitem->Dimensions[1]; //columns along x-axis
    unsigned short num_total_elements = dim1*dim2;
    unsigned short num_data_per_msg = COROS_SL_MAXBUFSIZE_DATA/DTSIZE[p_calparamitem->DataType];
    unsigned short num_msgs = num_total_elements/num_data_per_msg + 1;
    printf("#COROS DBG# cmdCallback_readCalValueByName \n\tDim:[%u %u]\n\tTotal:%u\n\tPerMsg:%u\n\tNumMsgs:%u\n",
          dim1, dim2, 
          num_total_elements,
          num_data_per_msg, 
          num_msgs);
    for(int i=0; i<num_msgs; i++){
      getQueueSlot(&p_respmsg); // get an empty slot from TX queue
      p_respmsg->respcode = rtnval? COROS_NEG_RESPCODE(p_cmdmsg->cmdcode):COROS_POS_RESPCODE(p_cmdmsg->cmdcode);
      strcpy(p_respmsg->respstr, p_cmdmsg->cmdstr); // name same as input
      unsigned short byteoffset = i*num_data_per_msg*DTSIZE[p_calparamitem->DataType]; //uint8 bytes offset
      unsigned short payloadcnt = ((num_total_elements-i*num_data_per_msg)>num_data_per_msg)?num_data_per_msg:(num_total_elements-i*num_data_per_msg); // payload data element count
      unsigned short payloadlen = payloadcnt*DTSIZE[p_calparamitem->DataType]; //uint8 bytes length of payload
      p_respmsg->datalen = payloadlen;
      p_respmsg->respoption[0] = (unsigned int)(i*num_data_per_msg); // series index start
      p_respmsg->respoption[1] = (unsigned int)p_respmsg->respoption[0]+payloadcnt-1; // series index end
      p_respmsg->respoption[2] = (unsigned int)num_msgs; //total number of messages
      p_respmsg->respoption[3] = (unsigned int)(num_msgs-(unsigned short)i-1); //remaining number of messages
      printf("#COROS DBG# cmdCallback_readCalValueByName for{}: byteoffset:%u payloadlen:%u series index:[%u %u]\n", byteoffset, payloadlen, p_respmsg->respoption[0], p_respmsg->respoption[1]);
      memcpy(p_respmsg->pdata, 
             (unsigned char*)(p_calparamitem->pData) + byteoffset,
             payloadlen);
    }
  }
  else{
    getQueueSlot(&p_respmsg); // get an empty slot from TX queue
    strcpy(p_respmsg->respstr, p_cmdmsg->cmdstr); //same as input
  }
  p_respmsg->respcode = rtnval? COROS_NEG_RESPCODE(p_cmdmsg->cmdcode):COROS_POS_RESPCODE(p_cmdmsg->cmdcode);
  return rtnval;
}



CoROS_RtnCode getCalParamItemByName(char *calname, CoROS_CalParam **pp_calparamitem)
{
	//printf("##COROS DBG# getCalParamItemByName # ENTRY: pp_calparamitem (%p @ %p)\n", *pp_calparamitem, pp_calparamitem);
    for (int i = 0; i < COROS_NUM_CALPARAMS; i++)
	{
        //printf("##COROS DBG# getCalParamItemByName #%u: %s [%u %u] Datatype: %u \n",CoROS_CalParamTable[i].Index, CoROS_CalParamTable[i].Name, CoROS_CalParamTable[i].Dimensions[0], CoROS_CalParamTable[i].Dimensions[1], CoROS_CalParamTable[i].DataType);
        //printf("##COROS DBG# getCalParamItemByName CoROS_CalParamTable[i] (%p)\n", &CoROS_CalParamTable[i]);
		if (!strcmp(calname, CoROS_CalParamTable[i].Name))
		{
			(*pp_calparamitem) = &CoROS_CalParamTable[i];
            //printf("##COROS DBG# getCalParamItemByName # EXIT: pp_calparamitem (%p @ %p)\n", *pp_calparamitem, pp_calparamitem);
			return COROS_OK;
		}
	}
	return COROS_NOK_INVALIDNAME;
}




CoROS_RtnCode setCalValue_Scalar(void *pdst, unsigned char *psrc, CoROS_DTIDX datatype)
{
	memcpy(pdst, psrc, DTSIZE[datatype]);
    //printf("##COROS# Set scalar value (Datatype: %u)\n",datatype);
	return COROS_OK;
}


/*
Set certain matrix area (index) of calibration parameter (pdst) with data (psrc).
setCalValue_RectMatrix function is actually compatible with scalar value.
*/
CoROS_RtnCode setCalValue_RectMatrix(void *pdst, unsigned char *psrc, CoROS_DTIDX datatype, unsigned int* dims, unsigned int* index)
{
	unsigned int xl = index[0]; // X-Left bound, zero indexed
	unsigned short xr = index[1]; // X-Right bound (inclusive), zero indexed
	unsigned short yt = index[2]; // Y-Top bound, zero indexed
	unsigned short yb = index[3]; // X-Bottom bound (inclusive), zero indexed
	unsigned char* uchar_pdst = (unsigned char*)pdst;
	for(unsigned short c=xl; c<xr+1; c++) //Columnwise tranverse
	{ 
		unsigned short offset_elements = c*dims[0]+yt; // offset of this column
		unsigned short len_thiscol = yb-yt+1; // length of data in this column (number of rows)
		memcpy(uchar_pdst+offset_elements*DTSIZE[datatype], psrc+(c-xl)*len_thiscol*DTSIZE[datatype], len_thiscol*DTSIZE[datatype]);
	}
    printf("##COROS# Set non-scalar value (Bound: %u %u %u %u Datatype: %u)\n",xl, xr, yt, yb, datatype);
	return COROS_OK;
}

//////////////////////////////////////////////
// DAQ FUNCTIONS /////////////////////////////
void processDAQList(){
  CoROS_RtnCode rtnval;
  unsigned char currmsgidx = 0;
  unsigned char cnt_sigincurrmsg = 0;
  unsigned short payloadlen = 0;
  CoROS_RespMsg* p_respmsg;
  //printf("##COROS DBG# processDAQList: %u\n", coros_daq_list.count);
  for(unsigned int i=0; i<coros_daq_list.count; i++){ // tranverse all ODT items
    if(currmsgidx != (coros_daq_list.odt_items+i)->msgindex)
    { // switch to a new message
      if(currmsgidx>0){
        p_respmsg->respoption[1] = cnt_sigincurrmsg; // set respoption[1] to number signals in message (last one)
        p_respmsg->datalen = (unsigned int)payloadlen;
        cnt_sigincurrmsg = 0; // and then reset signal count
        payloadlen = 0;
        printRespMsg(p_respmsg);
      }
      // Start a new message
      getQueueSlot(&p_respmsg); // get an empty slot from TX queue
      currmsgidx = (coros_daq_list.odt_items+i)->msgindex; // update index number
      p_respmsg->respoption[0] = currmsgidx; //set respoption[0] to current DAQ message index (one based)
      p_respmsg->respcode = COROS_POS_RESPCODE(COROS_CMDCODE_STARTDAQ);
      strcpy(p_respmsg->respstr, COMPILED_TIME_VERSION); // name same as input
    }
    unsigned short byteoffset = (coros_daq_list.odt_items+i)->msgoffset;
    unsigned short sigid = (coros_daq_list.odt_items+i)->signalid;
    unsigned short varoffset = (coros_daq_list.odt_items+i)->varoffset;
    unsigned short len = (coros_daq_list.odt_items+i)->bytelength;
    //printf("##COROS DBG# Msg: currmsgidx: %u | ByteOffset:%u ID:%u VarOffset:%u Length:%u\n", currmsgidx, byteoffset, sigid, varoffset, len);
    memcpy(&(p_respmsg->pdata[byteoffset]), ((unsigned char*)CoROS_SignalTable[sigid].pData+varoffset), len);
    cnt_sigincurrmsg++;
    payloadlen+=len;
    if(i==coros_daq_list.count-1){ // if reaches last odt
      p_respmsg->respoption[1] = cnt_sigincurrmsg; // set respoption[1] to number signals in message
      p_respmsg->datalen = (unsigned int)payloadlen;
      cnt_sigincurrmsg = 0; // and then reset signal count
      payloadlen = 0;
      //printRespMsg(p_respmsg);
    }
  }
}


static unsigned int curr_num_in_daqlist;
CoROS_RtnCode cmdCallback_setDAQList(CoROS_CmdMsg *p_cmdmsg){
  // Fill in response message
  CoROS_RespMsg* p_respmsg;
  char *verstr = p_cmdmsg->cmdstr; //version string generated on code generation
  getQueueSlot(&p_respmsg); // get an empty slot from TX queue
  strcpy(p_respmsg->respstr, verstr);
  p_respmsg->datalen = 0;
  // check version, and return negative response if not match
  printf("##COROS DBG# Version CMD:%s | LOCAL:%s | strcmp: %u\n", p_cmdmsg->cmdstr, COMPILED_TIME_VERSION, strcmp(p_cmdmsg->cmdstr, COMPILED_TIME_VERSION));
  if(strcmp(p_cmdmsg->cmdstr, COMPILED_TIME_VERSION)){ // if not match
    p_respmsg->respcode = COROS_NEG_RESPCODE(p_cmdmsg->cmdcode);
    *(p_respmsg->respoption) = (unsigned int)COROS_NOK_VERSION_NOTMATCH;
    return COROS_NOK_VERSION_NOTMATCH;
  }else{
    p_respmsg->respcode = COROS_POS_RESPCODE(p_cmdmsg->cmdcode);
    *(p_respmsg->respoption) = (unsigned int)COROS_OK;
  }

  unsigned int *cmdopt = p_cmdmsg->cmdoption;
  unsigned char *p_cmddata = p_cmdmsg->pdata; // every 8 bytes in data contains an ODTItem information
  //
  unsigned int num_total_odtitem = *cmdopt; // cmdoption[0]: number of total ODT items
  unsigned int num_currmsg_odtitem = *(cmdopt+1); // cmdoption[1]: number of ODT items in this message
  unsigned int num_cmdmsg = *(cmdopt+6); // cmdoption[6]: total number of command messages needed to transfer the DAQList
  unsigned int seqnum_cmdmsg = *(cmdopt+7); // cmdoption[7]: sequence number of current command message, one based
  if(seqnum_cmdmsg==1) // prepare memory on the first message (message index one-based)
  {
    if(NULL != coros_daq_list.odt_items){ // if not NULL, should be malloc-ed
      coros_daq_list.odt_items = (CoROS_ODTItem*) realloc(coros_daq_list.odt_items, num_total_odtitem*sizeof(CoROS_ODTItem)); // memory management
    }else{
      coros_daq_list.odt_items = (CoROS_ODTItem*) malloc(num_total_odtitem*sizeof(CoROS_ODTItem));
    }
    coros_daq_list.count = num_total_odtitem;
    curr_num_in_daqlist = 0;
    coros_daq_list.count = num_total_odtitem;
  }
  printf("##COROS DBG# Set DAQ Message #%u / %u\n", seqnum_cmdmsg, num_total_odtitem);
  for(int i=0; i<num_currmsg_odtitem*8; i+=8){
    (coros_daq_list.odt_items+curr_num_in_daqlist)->msgindex = *(p_cmddata+i);
    (coros_daq_list.odt_items+curr_num_in_daqlist)->msgoffset = *(p_cmddata+i+1);
    (coros_daq_list.odt_items+curr_num_in_daqlist)->signalid = *((unsigned short*)(p_cmddata+i+2)); //attention, cast from unsigned char to unsigned short 
    (coros_daq_list.odt_items+curr_num_in_daqlist)->varoffset = *((unsigned short*)(p_cmddata+i+4)); //attention, cast from unsigned char to unsigned short
    (coros_daq_list.odt_items+curr_num_in_daqlist)->bytelength = *(p_cmddata+i+6);
    printf("##COROS DBG# Set DAQ Signal #%u: %u | MsgOffset:%u ID:%u VarOffset:%u Length:%u\n", 
            curr_num_in_daqlist,
            (coros_daq_list.odt_items+curr_num_in_daqlist)->msgindex, 
            (coros_daq_list.odt_items+curr_num_in_daqlist)->msgoffset, 
            (coros_daq_list.odt_items+curr_num_in_daqlist)->signalid,
            (coros_daq_list.odt_items+curr_num_in_daqlist)->varoffset, 
            (coros_daq_list.odt_items+curr_num_in_daqlist)->bytelength);
    curr_num_in_daqlist++;
  }
  return COROS_OK;
}


CoROS_RtnCode cmdCallback_startDAQ(CoROS_CmdMsg *p_cmdmsg){
  printf("##CoROS# DAQ Started...\n");
  coros_daq_enable = 0x01;
  return COROS_OK;
}

CoROS_RtnCode cmdCallback_stopDAQ(CoROS_CmdMsg *p_cmdmsg){
  printf("##CoROS# DAQ Stopped...\n");
  coros_daq_enable = 0x00;
  return COROS_OK;
}





//////////////////////////////////////////////////
//////////////////////////////////////////////////
//DEBUG FUNCTION: print calibration as per idx
void cmdCallback_dbgprint(unsigned short idx){
    unsigned int index = CoROS_CalParamTable[idx].Index;
    CoROS_DTIDX datatype = CoROS_CalParamTable[idx].DataType;
    unsigned short dim1 = CoROS_CalParamTable[idx].Dimensions[0];
    unsigned short dim2 = CoROS_CalParamTable[idx].Dimensions[1];
    const char* name = CoROS_CalParamTable[idx].Name;
    printf("#%u:\tDataType:%u\tDim:[%u, %u]\t%s\n", index, datatype, dim1, dim2, name);
    printf("Data:[ ");
    if(dim1>1) {printf("\n");} // enter line print matrix
    for(unsigned int i=0; i<dim1; i++){
        for(unsigned int j=0; j<dim2; j++){
            switch(datatype){
                case CoROS_DTIDX_INT8:
                    {char* ptr = (char*) CoROS_CalParamTable[idx].pData;
                    printf(" %d", *(ptr+j*dim1+i));break;}
                case CoROS_DTIDX_UINT8:
                    {unsigned char* ptr = (unsigned char*) CoROS_CalParamTable[idx].pData;
                    printf(" %u", *(ptr+j*dim1+i));break;}
                case CoROS_DTIDX_UINT16:
                    {unsigned short* ptr = (unsigned short*) CoROS_CalParamTable[idx].pData;
                    printf(" %u", *(ptr+j*dim1+i));break;}
                case CoROS_DTIDX_UINT32:
                    {unsigned int* ptr = (unsigned int*) CoROS_CalParamTable[idx].pData;
                    printf(" %u", *(ptr+j*dim1+i));break;}
                case CoROS_DTIDX_INT16:
                    {short int* ptr = (short int*) CoROS_CalParamTable[idx].pData;
                    printf(" %d", *(ptr+j*dim1+i));break;}
                case CoROS_DTIDX_INT32:
                    {int* ptr = (int*) CoROS_CalParamTable[idx].pData;
                    printf(" %d", *(ptr+j*dim1+i));break;}
                case CoROS_DTIDX_INT64:
                    {long int* ptr = (long int*) CoROS_CalParamTable[idx].pData;
                    printf(" %ld", *(ptr+j*dim1+i));break;}
                case CoROS_DTIDX_FLOAT:
                    {float* ptr = (float*) CoROS_CalParamTable[idx].pData;
                    printf(" %.3f", *(ptr+j*dim1+i));break;}
                case CoROS_DTIDX_DOUBLE:
                    {double* ptr = (double*) CoROS_CalParamTable[idx].pData;
                    printf(" %.3f", *(ptr+j*dim1+i));break;}
                default:
                    {unsigned char* ptr = (unsigned char*) CoROS_CalParamTable[idx].pData;
                    printf(" %02X", *(ptr+j*dim1+i));break;}
            }
        }
        if(dim1>1) {printf("\n");}
    }
    printf("]\n\n\n");
}


void printCmdMsg(CoROS_CmdMsg *p_cmdmsg){
  printf("##COROS DBG# Command Message Code:0x%04X | Str:%s | Option:[", p_cmdmsg->cmdcode, p_cmdmsg->cmdstr);
  for(int i=0;i<8;i++){
    printf(" %u ", *(p_cmdmsg->cmdoption+i));
  }
  printf("]\n##\t Data:[");
  for(int i=0;i<COROS_SL_MAXBUFSIZE_DATA;i++){
    printf(" %u ", *(p_cmdmsg->pdata+i));
  }
  printf("]\n");
}

void printRespMsg(CoROS_RespMsg* p_respmsg){
  printf("##COROS DBG# Response Message Code:0x%04X | Str:%s | Option:[", p_respmsg->respcode, p_respmsg->respstr);
  for(int i=0;i<8;i++){
    printf(" %u ", p_respmsg->respoption[i]);
  }
  printf("]\n##\t Data:[");
  for(int i=0;i<COROS_SL_MAXBUFSIZE_DATA;i++){
    printf(" %u ", p_respmsg->pdata[i]);
  }
  printf("]\n");
}


%closefile coros_cfile

%% ---------GENREATE CPP FILE END--------------


%% ---------GENREATE JSON CONFIG FILE--------------
%assign jsonfilename = CompiledModel.Name
%openfile json_file = "%<jsonfilename>.json"
{
"ModelName":"%<CompiledModel.Name>",
"TimeVersion":"%<random_version_id>",
"ParameterTable":
    [%<jsonfilebuffer_para_notrailcomma>],
"SignalTable":
    [%<jsonfilebuffer_sig_notrailcomma>]
}

%closefile json_file
%% ---------GENREATE JSON CONFIG FILE END--------------




%<LibAddToCommonIncludes("%<hFileName>.h")>
%<LibAddToModelSources("%<cFileName>")>

%endfunction





%% Function: BlockInstanceSetup ===========================================
%%
%function BlockInstanceSetup(block, system) void
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"
  %else
    %<LibBlockSetIsExpressionCompliant(block)>
  %endif
  %%
%endfunction

%% Function: Start ========================================================
%%
%function Start(block, system) Output
  %%
%assign namestrptr = LibBlockInputSignalAddr(1, "", "", 0)
%assign cmdoption = LibBlockInputSignalAddr(3, "", "", 0)
%assign payloadptr = LibBlockInputSignalAddr(4, "", "", 0)

  /* Construct command message*/
  coros_cmdmsg.cmdstr = (char*)%<namestrptr>;
  coros_cmdmsg.cmdoption = %<cmdoption>;
  coros_cmdmsg.pdata = %<payloadptr>;
  %%

  /**/
  coros_daq_list.count = 0; //initialize DAQ
%endfunction

%% Function: Outputs ======================================================
%%
%function Outputs(block, system) Output
  %%
%assign cmdcode = LibBlockInputSignal(0, "", "", 0)
%assign namestrptr = LibBlockInputSignalAddr(1, "", "", 0)
%assign namestrlen = LibBlockInputSignal(2, "", "", 0)
%assign payloadlen = LibBlockInputSignal(5, "", "", 0)

  /* Construct command message and dispatch*/
  coros_cmdmsg.cmdcode = %<cmdcode>;
  *(%<namestrptr>+%<namestrlen>) = '\0'; // Add string ending "\0" to convert to string
  coros_cmdmsg.datalen = %<payloadlen>;
  // Receive command message, process and dispatch to corrresponding callback function
  cmdDispatch(&coros_cmdmsg);
  
  %%
%endfunction

%% Function: Terminate ====================================================
%%
%function Terminate(block, system) Output
  %%

  %%
%endfunction

%% [EOF]
